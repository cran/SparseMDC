<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Overview</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<hr/>

<p>references:</p>

<ul>
<li>id: biase2014
title: Cell fate inclination within 2-cell and 4-cell mouse embryos revealed by single-cell RNA sequencing
author:

<ul>
<li>family: Biase
given: Fernando H.</li>
<li>family: Cao
given: Xiaoyi</li>
<li>family: Zhong
given: Sheng
container-title: Genome Research
volume: 11
URL: &#39;<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4216920/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4216920/</a>&#39;
DOI: 10.1101/gr.177725.114
issue: 4
publisher: Genome Research
page: 1787-1796
type: article-journal
issued:
year: 2014
month: 11</li>
</ul></li>
</ul>

<hr/>

<h2>Overview</h2>

<p>The SparseMDC package implements the multiple condition SparseDC model. This package is suitable for data coming from &gt;=2 ordered conditions. This method clusters samples (cells) in each condition, links corresponding clusters (cell-types) across conditions, identifies a unique set of characteristic features (marker genes) for each cluster and identifies features which characterize the condition change for each cluster. This vignetter will guide you through the application of SparseMDC including pre-processing of data, calculation of penalty parameters, and extraction.</p>

<h2>Section 1 - Preliminaries</h2>

<p>SparseMDC was designed for the analysis of single-cell RNA-squencing(scRNA-seq) data coming from multiple ordered conditions. These conditions could include cells before and after treatment, cells at different developmental stages, or cells taken from different time points in a time course experiment. The data SparseMDC takes as input is scRNA-seq gene expression data. SparseMDC assumes that this data has been properly normalized for sequencing depth and other technical effects prior to the application of SparseMDC. </p>

<h3>1-1 Load SparseMDC</h3>

<p>The first step is to install and load the SparseMDC package. </p>

<pre><code class="r"># install.packages(&quot;SparseMDC&quot;)
library(&quot;SparseMDC&quot;)
</code></pre>

<pre><code>## Loading required package: doRNG
</code></pre>

<pre><code>## Loading required package: foreach
</code></pre>

<pre><code>## Loading required package: rngtools
</code></pre>

<pre><code>## Loading required package: pkgmaker
</code></pre>

<pre><code>## Loading required package: registry
</code></pre>

<pre><code>## 
## Attaching package: &#39;pkgmaker&#39;
</code></pre>

<pre><code>## The following object is masked from &#39;package:base&#39;:
## 
##     isFALSE
</code></pre>

<h3>1-2 Real Data Example:Biase Data</h3>

<p>To demonstrate the data format and application of SparseMDC scRNA-seq data created by Biase
et al. to study cell fate inclination in mouse embryos [@biase2014] will be used. This dataset contains 
gene expression, FPKM, measurements for 49 cells and 16,514 genes. The cells in
the dataset come from three different cell types, zygote, two-cell embryos and
four-cell embryos. While the cells in this dataset are all from a single
condition we have dveloped an approach to split the data into three conditions so
that the linking of clusters across conditions can be demonstrated. For this example we split the data so that the zygote and 10 two-cell cells are in condition A, 10 two-cell and 10 four-cell cells are in condition B and 10 four-cells cells are in condition C.</p>

<pre><code class="r"># Load Dataset
data(data_biase)
# Summarize condition vector 
summary(as.factor(condition_biase))
</code></pre>

<pre><code>##  A  B  C 
## 19 20 10
</code></pre>

<pre><code class="r"># Compare condition and cell type
table(condition_biase, cell_type_biase)
</code></pre>

<pre><code>##                cell_type_biase
## condition_biase Four-cell Embryo Two-cell Embryo Zygote
##               A                0              10      9
##               B               10              10      0
##               C               10               0      0
</code></pre>

<h3>1-3 Data Formatting</h3>

<p>SparseMDC takes as input scRNA-seq gene expression data for multiple conditions. This data should be stored as a list with each entry containing a gene expression matrix for a single condition. The data should be stored with genes as rows and cells as columns. </p>

<p>The next step to check the data is stored correctly, separate the data into different conditions, and store the data as a list</p>

<pre><code class="r"># Check rows are genes and columns are cells 
head(data_biase[,1:5])
</code></pre>

<pre><code>##                    GSM1377859 GSM1377860 GSM1377861 GSM1377862 GSM1377863
## ENSMUSG00000000001   3.288693   3.631147   2.290201   3.241467  3.4727581
## ENSMUSG00000000028   4.547849   4.533851   4.560077   4.682483  4.8076946
## ENSMUSG00000000037   3.662392   3.154039   3.192203   3.767524  3.2131756
## ENSMUSG00000000049   0.000000   0.000000   0.000000   0.000000  0.0000000
## ENSMUSG00000000056   2.544338   1.889089   2.143146   1.975677  1.9743810
## ENSMUSG00000000078   1.127634   1.278873   1.085679   2.132017  0.9719827
</code></pre>

<pre><code class="r"># Separate data by condition
biase_A &lt;- data_biase[,which(condition_biase == &quot;A&quot;)]
cell_type_A &lt;- cell_type_biase[which(condition_biase == &quot;A&quot;)]
biase_B &lt;- data_biase[,which(condition_biase == &quot;B&quot;)]
cell_type_B &lt;- cell_type_biase[which(condition_biase == &quot;B&quot;)]
biase_C &lt;- data_biase[,which(condition_biase == &quot;C&quot;)]
cell_type_C &lt;- cell_type_biase[which(condition_biase == &quot;C&quot;)]
# Move data into list
dat_l &lt;- list(biase_A, biase_B, biase_C)
</code></pre>

<h2>Section 2 - Preprocessing</h2>

<p>Prior to the application of SparseMDC the data needs to be normalized for sequencing depth and other technical effects and centered on a gene-by-gene basis. We also recommend that the data is log-transformed.
To do this we have included a function that can easily pre-process the data. For the normalization it is recommended that users make use of one of the many methods that exist for normalizing scRNA-Seq data. The centering of the data is crucially important to the function of SparseMDC and is vital to accurately clustering the data and identifying marker genes. We recommend that all users use this function to center their data and that only experienced users set &ldquo;center=FALSE&rdquo;.</p>

<p>The Biase data are FPKM measurements of gene expression and so have been 
normalized using an alternate method as advised. This means we can set 
&ldquo;norm = FALSE&rdquo;. The Biase data then needs to be both log transformed and
centered so we can set &ldquo;log =TRUE&rdquo;&ldquo; and &quot;center = TRUE&rdquo;. We also set &ldquo;dim=3&rdquo; which is the number of conditions in the data:</p>

<pre><code class="r">pdat &lt;- pre_proc_data(dat_l, dim = 3, norm = FALSE, log = TRUE, center = TRUE)
</code></pre>

<p>The data is returned as list containing the centered and log-transformed data. To check the data has been correctly centered we can view the rowSums for each gene.</p>

<pre><code class="r"># Check condition A
summary(rowSums(pdat[[1]]))
</code></pre>

<pre><code>##     Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
## -14.4967  -2.1420   0.2121   0.5778   3.4113  14.4990
</code></pre>

<pre><code class="r"># Check condition B
summary(rowSums(pdat[[2]]))
</code></pre>

<pre><code>##      Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
## -10.44322  -1.74132  -0.03822  -0.19947   1.27058  11.61908
</code></pre>

<pre><code class="r"># Check condition C
summary(rowSums(pdat[[3]]))
</code></pre>

<pre><code>##     Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
## -11.8084  -2.0521  -0.2319  -0.3783   1.3200  11.1150
</code></pre>

<h2>Section 3 - Penalty Parameter Estimation</h2>

<p>Now that the data has been centered and log-transformed it is time to estimate the penalty parameters used in SparseMDC. The target function of SparseMDC contains two penalty parameters, \(\lambda_{1}\) and \(\lambda_{2}\). The \(\lambda_{1}\) penalty acts on the center value of each cluster driving them towards zero and revealing the marker genes for each cell-type. This term then controls the number of non-zero center values which are the characteristic features (marker genes) in the solution. Larger values of \(\lambda_{1}\) lead to a sparser solution. The \(\lambda_{2}\) penalty acts on the difference between center values for each cluster across conditions. This has the effect of driving similar cells across conditions together, linking clusters across conditions, and revealing features which characterize the change. Larger values of \(\lambda_{2}\) lead to less change across conditions. Details on the estimation of these parameters can be found in the supplementary material of the manuscript. </p>

<h3>3-1 \(\lambda_{1}\)</h3>

<p>To estimate \(\lambda_{1}\) we just need to provide the centered and log-transformed data, the number of conditions and the number of clusters. As there are three cell-types present we set the number of clusters, \code{nclust} as 3. </p>

<pre><code class="r">lambda1 &lt;- lambda1_calculator(pdat, dim = 3, nclust = 3 )
lambda1
</code></pre>

<pre><code>## [1] 0.5909344 0.5909344 0.5909344
</code></pre>

<h3>3-2 \(\lambda_{2}\)</h3>

<p>To estimate \(\lambda_{2}\) we again need to provide the centered and log-transformed data, the number of conditions and clusters as well as the calculated \(\lambda_{1}\) value.</p>

<pre><code class="r">lambda2 &lt;- lambda2 &lt;- lambda2_calculator(pdat, dim = 3, nclust = 3, 
                                         lambda1 = lambda1)
lambda2
</code></pre>

<pre><code>## [1] 1.732187 1.732187
</code></pre>

<h2>Section 4 - SparseMDC</h2>

<p>Once the parameters have been calculated we are now ready to apply SparseMDC. SparseMDC requires us to input the processed data, the number of conditions and clusters and the calculated penalty parameters. Other parameters which can changed are:</p>

<ul>
<li>\code{nitter} - The maximum number of iterations for each start, default value is 20.</li>
<li>\code{nstarts} - The number of starts for the algorithm, default value is 50.</li>
<li>\code{init_iter} - The number of interations of K-means used to generate the starting centers,
default value is 5.</li>
</ul>

<h3>4-1 Apply SparseMDC</h3>

<pre><code class="r"># Apply SparseMDC
smdc_res &lt;- sparse_mdc(pdat,  dim = 3, nclust = 3, lambda1 = lambda1, 
                      lambda2 = lambda2, nstarts = 50, init_iter = 1)
</code></pre>

<pre><code>## Calculating start values
</code></pre>

<pre><code>## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration

## Warning: did not converge in 1 iteration
</code></pre>

<pre><code>## The number of unique start values is:  22
## Start number:  1
## Iteration:  1
## Iteration:  2
## Iteration:  3
## Iteration:  4
## Iteration:  5
## Iteration:  6
## Iteration:  7
## Iteration:  8
## Clusters are unchanged!
## The score for start  1  is  81157.58
## New minimum score!
## Start number:  2
## Iteration:  1
## Iteration:  2
## Iteration:  3
## Iteration:  4
## Iteration:  5
## Iteration:  6
## Iteration:  7
## Iteration:  8
## Clusters are unchanged!
## The score for start  2  is  81157.58
## New minimum score!
## Start number:  3
## Iteration:  1
## Iteration:  2
## Iteration:  3
## Iteration:  4
## Iteration:  5
## Iteration:  6
## Iteration:  7
## Iteration:  8
## Clusters are unchanged!
## The score for start  3  is  81157.58
## New minimum score!
## Start number:  4
## Iteration:  1
## Iteration:  2
## Iteration:  3
## Iteration:  4
## Iteration:  5
## Iteration:  6
## Iteration:  7
## Iteration:  8
## Clusters are unchanged!
## The score for start  4  is  81157.58
## New minimum score!
## Start number:  5
## Iteration:  1
## Iteration:  2
## Iteration:  3
## Iteration:  4
## Iteration:  5
## Iteration:  6
## Iteration:  7
## Iteration:  8
## Clusters are unchanged!
## The score for start  5  is  81157.58
## New minimum score!
## Start number:  6
## Iteration:  1
## Iteration:  2
## Iteration:  3
## Iteration:  4
## Iteration:  5
## Iteration:  6
## Iteration:  7
## Iteration:  8
## Clusters are unchanged!
## The score for start  6  is  81157.58
## New minimum score!
## Start number:  7
## Iteration:  1
## Iteration:  2
## Clusters are unchanged!
## The score for start  7  is  82628.38
## Start number:  8
## Iteration:  1
## Iteration:  2
## Iteration:  3
## Iteration:  4
## Iteration:  5
## Iteration:  6
## Iteration:  7
## Iteration:  8
## Clusters are unchanged!
## The score for start  8  is  81157.58
## New minimum score!
## Start number:  9
## Iteration:  1
## Iteration:  2
## Iteration:  3
## Iteration:  4
## Iteration:  5
## Iteration:  6
## Iteration:  7
## Iteration:  8
## Clusters are unchanged!
## The score for start  9  is  81157.58
## New minimum score!
## Start number:  10
## Iteration:  1
## Iteration:  2
## Iteration:  3
## Iteration:  4
## Iteration:  5
## Iteration:  6
## Iteration:  7
## Iteration:  8
## Clusters are unchanged!
## The score for start  10  is  81157.58
## New minimum score!
## Start number:  11
## Iteration:  1
## Iteration:  2
## Iteration:  3
## Iteration:  4
## Iteration:  5
## Iteration:  6
## Iteration:  7
## Iteration:  8
## Clusters are unchanged!
## The score for start  11  is  81157.58
## New minimum score!
## Start number:  12
## Iteration:  1
## Iteration:  2
## Clusters are unchanged!
## The score for start  12  is  81154.73
## New minimum score!
## Start number:  13
## Iteration:  1
## Iteration:  2
## Iteration:  3
## Iteration:  4
## Iteration:  5
## Clusters are unchanged!
## The score for start  13  is  82273.59
## Start number:  14
## Iteration:  1
## Iteration:  2
## Iteration:  3
## Iteration:  4
## Iteration:  5
## Iteration:  6
## Iteration:  7
## Iteration:  8
## Clusters are unchanged!
## The score for start  14  is  81157.58
## Start number:  15
## Iteration:  1
## Iteration:  2
## Iteration:  3
## Iteration:  4
## Iteration:  5
## Clusters are unchanged!
## The score for start  15  is  82273.59
## Start number:  16
## Iteration:  1
## Iteration:  2
## Iteration:  3
## Iteration:  4
## Iteration:  5
## Iteration:  6
## Iteration:  7
## Iteration:  8
## Clusters are unchanged!
## The score for start  16  is  81157.58
## Start number:  17
## Iteration:  1
## Iteration:  2
## Iteration:  3
## Iteration:  4
## Clusters are unchanged!
## The score for start  17  is  81163.64
## Start number:  18
## Iteration:  1
## Iteration:  2
## Iteration:  3
## Iteration:  4
## Iteration:  5
## Iteration:  6
## Iteration:  7
## Iteration:  8
## Clusters are unchanged!
## The score for start  18  is  81157.58
## Start number:  19
## Iteration:  1
## Iteration:  2
## Clusters are unchanged!
## The score for start  19  is  81154.73
## New minimum score!
## Start number:  20
## Iteration:  1
## Iteration:  2
## Iteration:  3
## Iteration:  4
## Iteration:  5
## Iteration:  6
## Iteration:  7
## Iteration:  8
## Clusters are unchanged!
## The score for start  20  is  81157.58
## Start number:  21
## Iteration:  1
## Iteration:  2
## Iteration:  3
## Iteration:  4
## Iteration:  5
## Iteration:  6
## Iteration:  7
## Iteration:  8
## Clusters are unchanged!
## The score for start  21  is  81157.58
## Start number:  22
## Iteration:  1
## Iteration:  2
## Iteration:  3
## Iteration:  4
## Iteration:  5
## Iteration:  6
## Iteration:  7
## Iteration:  8
## Clusters are unchanged!
## The score for start  22  is  81157.58
</code></pre>

<h3>4-2 Examine Results</h3>

<p>After the application the results are stored as a list. The first item contains the clustering assignments while the second item contains the calculated center values. Each of these items is also a list and contains the solution for each condition in its corresponding entry, i.e. the clusters for condition A are stored in the first entry of the cluster list.</p>

<pre><code class="r"># Extract clustering solution
clusters &lt;- smdc_res[[1]]
# Extract clusters for condition A
clusters_A &lt;- clusters[[1]]
# Extract clusters for condition B
clusters_B &lt;- clusters[[2]]
# Extract clusters for condition C
clusters_C &lt;- clusters[[3]]
# Compare clusters and cell type 
table(cell_type_A, clusters_A)
</code></pre>

<pre><code>##                  clusters_A
## cell_type_A        1  2
##   Two-cell Embryo 10  0
##   Zygote           1  8
</code></pre>

<pre><code class="r">table(cell_type_B, clusters_B)
</code></pre>

<pre><code>##                   clusters_B
## cell_type_B         1  3
##   Four-cell Embryo  0 10
##   Two-cell Embryo  10  0
</code></pre>

<pre><code class="r">table(cell_type_C, clusters_C)
</code></pre>

<pre><code>##                   clusters_C
## cell_type_C         3
##   Four-cell Embryo 10
</code></pre>

<pre><code class="r"># View full comparision
table(c(cell_type_A, cell_type_B, cell_type_C), 
      c(clusters_A, clusters_B, clusters_C))
</code></pre>

<pre><code>##                   
##                     1  2  3
##   Four-cell Embryo  0  0 20
##   Two-cell Embryo  20  0  0
##   Zygote            1  8  0
</code></pre>

<p>The centers are extracted in a similar manner.</p>

<pre><code class="r"># Extract centers
centers &lt;- smdc_res[[2]]
# Extract centers for condition A
centers_A &lt;- centers[[1]]
# Extract centers for condition B
centers_B &lt;- centers[[2]]
# Extract centers for condition C
centers_C &lt;- centers[[3]]
</code></pre>

<h3>4-3 Housekeeping Marker Genes</h3>

<p>The center results from SparseMDC can be used to identify marker genes of different categories from the result. Full details on the different categories of marker genes can be found in the original manuscript but a brief desciption is:</p>

<ul>
<li>Housekeeping marker genes - These are marker genes for a cell type/cluster in all conditions and there expression is consistent in each condition. </li>
<li>Condition-dependent marker genes - These are marker genes for a cell type/cluster in two or more conditions but their expression depends on the condition.</li>
<li>Condition-specific marker genes - These are marker genes for a cell type/cluster in a single condition. </li>
</ul>

<p>The center values are stored in the column corresponding to the cluster number. For example the center values for cluster 1 in condition A are stored in the first column of \code{centers_A}.</p>

<p>To identify housekeeping marker genes for cluster 1 we can use the following approach:</p>

<pre><code class="r">#Identify housekeeping marker gene index
clus_1_hk_gene_ind &lt;- which(centers_A[,1] == centers_B[,1] &amp; 
                              centers_B[,1] == centers_C[,1] &amp; 
                              centers_A[,1] != 0)
# Identify the housekeeping marker genes
clus_1_hk_genes &lt;- row.names(data_biase)[clus_1_hk_gene_ind]
</code></pre>

<h3>4-4 Condition-Dependent/Condition-Specific Marker Genes</h3>

<p>Condition-dependent marker genes can be identified in the following way.</p>

<pre><code class="r">clus_1_cd_gene_ind &lt;- which(centers_A[,1] != 0 &amp; centers_B[,1] != 0 &amp; 
                              centers_A[,1] != centers_B[,1] |
                            centers_A[,1] != 0 &amp; centers_C[,1] != 0 &amp;
                              centers_A[,1] != centers_C[,1] |
                            centers_B[,1] != 0 &amp; centers_C[,1] != 0 &amp;
                              centers_B[,1] != centers_C[,1])
</code></pre>

<p>Condition-specific genes for cluster 1 can be identified in the following way.</p>

<pre><code class="r"># Identify condition A specific genes
clus_1_A_cs_ind &lt;- which(centers_A[,1] != 0 &amp; centers_B[,1] == 0 &amp; 
                           centers_C[,1] == 0)
clus_1_A_cs_genes &lt;- row.names(data_biase)[clus_1_A_cs_ind]
# Identify condition B specific genes
clus_1_B_cs_ind &lt;- which(centers_A[,1] == 0 &amp; centers_B[,1] != 0 &amp; 
                           centers_C[,1] == 0)
clus_1_B_cs_genes &lt;- row.names(data_biase)[clus_1_B_cs_ind]
# Identify condition C specific genes
clus_1_C_cs_ind &lt;- which(centers_A[,1] == 0 &amp; centers_B[,1] == 0 &amp; 
                           centers_C[,1] != 0)
clus_1_C_cs_genes &lt;- row.names(data_biase)[clus_1_C_cs_ind]
</code></pre>

<h2>References</h2>

</body>

</html>
